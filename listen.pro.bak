%-*-Prolog-*-  
% listen indented on 3/5/2000 by 'JOLI' 1.0.

%-------------------------------------------------------------------

% listen.pro - the main listener
%
% Copyright (c) 1992-2002 Amzi! inc. All rights reserved
%
% $Log: listen.pro,v $
% Revision 1.13  2005/10/16 17:49:37  mary
% Fix a variety of debugger problems with Eclipse 3.1 and change in stop button.
%
% Revision 1.12  2005/10/14 22:31:52  mary
% Fix error handling in the debugger.
%
% Revision 1.11  2005/02/09 17:35:39  dennis
% ?var added
%
% Revision 1.10  2004/05/05 16:31:44  dennis
% added tcltk stuff
%
% Revision 1.9  2004/03/16 22:33:50  dennis
% added debugger escape to secondary listener, fixed control structures dcg bug
%
% Revision 1.8  2004/01/21 14:47:48  mary
% Fix messages for all platforms
%
% Revision 1.7  2004/01/21 14:07:05  mary
% Put in days left for all platforms
%
% Revision 1.6  2003/12/26 18:23:22  mary
% Added missing parentheses.
%
% Revision 1.5  2003/11/12 16:47:48  mary
% Restructure keys to make it more maintainable. Have debug64 check license.
%
% Revision 1.4  2003/11/11 23:43:35  mary
% More licensing and LAN edition tweaks.
%
% Revision 1.3  2003/11/02 21:49:22  mary
% More 7.0.7 release candidate changes.
%
% Revision 1.2  2003/10/30 17:05:01  mary
% Moved debugging predicates from alis.pro to listen.pro.
%
% Revision 1.1.1.1  2003/09/11 02:15:11  dennis
% Starting release 7.0
%
% Revision 1.34  2003/08/30 16:31:08  dennis
% loads all go to ensure_loaded now
%
% Revision 1.33  2003/08/30 12:40:47  dennis
% *** empty log message ***
%
% Revision 1.32  2003/07/24 17:30:41  dennis
% support for debugging compiled code, reorg of alib etc to support that
%
% Revision 1.31  2003/06/13 18:37:01  dennis
% date_time and other fixes
%
% Revision 1.30  2003/03/24 15:49:01  dennis
% getting read for 6.4.0 alpha
%
% Revision 1.29  2003/03/23 01:51:34  dennis
% Made list for Dennis
%
% Revision 1.28  2003/03/15 14:34:05  dennis
% Many changes in debug64 and proto_debug, source code
% debugging is closer to a reality
%
% Revision 1.27  2003/02/13 23:44:36  dennis
% latest debug64 stuff
%
% Revision 1.26  2003/01/29 00:22:22  dennis
% removed user_more
%
% Revision 1.25  2003/01/25 18:49:23  dennis
% debug64 preliminary stuff added in various places
%
% Revision 1.24  2002/12/26 17:44:02  dennis
% Changes to listener to make it easier to access listener from IDE.
%
% Revision 1.23  2002/11/20 14:54:44  dennis
% added support for user defined streams, fixed java jni bug with
% extended predicates
%
% Revision 1.22  2002/07/04 16:20:26  dennis
% support academic registration
%
% Revision 1.21  2002/06/10 15:10:47  dennis
% locking working
%
% Revision 1.20  2002/06/09 17:32:12  dennis
% lock dialog in IDE, created cMOD, cGOAL cTYPEs so its possible
% to break apart :/2 structures from the IDE
%
% Revision 1.19  2002/06/09 03:07:58  dennis
% added locking
%
% Revision 1.18  2002/05/20 04:34:12  dennis
% final changes
%
% Revision 1.17  2002/05/18 23:45:38  dennis
% makefile, unlock changes
%
% Revision 1.16  2002/05/18 14:16:04  dennis
% First 6.2.1 - TA DA!
%
% Revision 1.15  2002/05/15 16:59:10  dennis
% Final fixes for last 6.1 build, 80
%
% Revision 1.14  2002/04/25 03:42:23  dennis
% more documentation, logicbase.htm, and some fiddling with sources
%
% Revision 1.13  2002/04/19 19:41:44  dennis
% fixed retract bug with sorted/indexed clauses, implemented abolish for
% those types as well
%
% Revision 1.12  2002/04/09 17:31:18  ray
% corrected error in divide and mod arith
%
% Revision 1.11  2001/10/02 16:05:22  dennis
% changed streams, cleaner interface to lex, reimplemented
% readers as buffer between the two
%
% Revision 1.10  2001/08/29 19:34:34  ray
% Corrections to 'seen' in alib etc.
%
% Revision 1.9  2001/04/02 21:50:14  dennis
% got debugger working again
%
% Revision 1.8  2001/03/16 00:29:07  dennis
% compiled metapredicates
%
% Revision 1.7  2001/02/21 04:46:43  dennis
% debugger working, updated documentation for 6.1
%
% Revision 1.6  2001/02/18 18:47:14  ray
% Substituted end_of_file for !EOS
% Replaced 0' with 0' for char code denotation
% Introduced 0' quote mark as default for strings
%
% Revision 1.5  2001/02/08 22:56:46  dennis
% string bug fixes, modularized compiler and listener
%
% Revision 1.4  2001/02/05 03:11:45  dennis
% Fixed nasty heap GC bug, other minor fixes
%
% Revision 1.3  2001/01/30 16:47:29  dennis
% Made, after many trials, alib into amzi_system module.
%
% Revision 1.2  2001/01/06 03:46:02  dennis
% listener working with import/export
%
% Revision 1.1.1.1  2000/12/29 02:18:06  dennis
% moved to a6
%
% Revision 1.11  2000/10/30 15:11:46  ray
% Extended compiler, loader and linker for real data.
% Added arithmetic primitives for rational data in alib.pro
%
% Revision 1.10  2000/10/14 22:14:06  ray
% redefined GD for very long arrays, and named the descriptor substructure and enhanced all references
%
% Revision 1.9  2000/10/12 19:05:14  ray
% Corrected mult for real.
% Added clock for integer calculation of time in milliseconds.
% Added run time printout to alis
%
% Revision 1.8  2000/10/01 16:20:04  dennis
% cleaned up modules, ddb, got defined, abolish and friends working
%
% Revision 1.7  2000/05/15 11:24:49  dennis
% fixed some minor bugs, started modules
%
% Revision 1.6  2000/04/10 01:01:39  ray
% *** empty log message ***
%
% Revision 1.5  2000/03/28 23:47:53  dennis
% Changed all tabs to three spaces, and also changed Logic Server
% to use void* for TERM externally and cast to Cell* in LEngine
% implementation.
%
% Revision 1.4  2000/03/28 01:05:18  dennis
% merged Ray's changes with bigdig.  bigdig is at point where
% new Cell class is used, but there are no modules in the system.
%
% Revision 1.2.2.1  2000/02/26 20:56:14  dennis
% Removed local atoms from compiler, and old module support, so
% compiler and listener are all global for now.  Also made member/2
% and friends built-ins as well as the bug predicates.
%
%
%--------------------------------------------------------------------

:- module(amzi_listener).
:- import(amzi_debugger).
:- import(amzi_register).
:- end_module(amzi_listener).

:- body(amzi_listener).
:- export([
      do$/1,
      exp$listen$term/2,
      except$/1,
      go_listen/1,
      eclipse_listen/1,
      leash/0,
      listen_again/1,
      spy/0,
      bug_message/1,
      bug_goal_report/4,
      bug_action/1,
      bug_noclause/3 ]).

%-------------------------------------------------------
% Main listener loop
%

go_listen :-
   greetings,
   write(`\nType 'quit.' to exit\n`),
   top$loop(`\n?- `),
   !.

eclipse_listen :-
%   top$loop$no$catch(`\n?- `).
   top$loop(`\n?- `).

listen_again :-
   top$loop(`\n??- `).
      
% Make sure listener continues to work from current_user
% rather than current_stream, which might be reset by
% a see or tell.

top$loop$no$catch(Prompt) :-
   repeat,
   current_user(UserIn, UserOut, _),
   fflush(UserIn),
   fflush(UserOut),
   set_creep(on),
   write(UserOut, Prompt), 
   fflush(UserOut),
   read(UserIn, X),
   listen$(X).

top$loop(Prompt) :-
   repeat,
   amzi_system:set_debug$state(step_into),
   current_user(UserIn, UserOut, _),
   fflush(UserIn),
   fflush(UserOut),
   set_creep(on),
   write(UserOut, Prompt), 
   fflush(UserOut),
   catch( (
     read(UserIn, X),
     %fflush(UserIn),
     listen$(X) ),
     E, except$(E)).

%except$(E) :-
%   amzi_system:debug64$initialized,
%   !,
%   amzi_system:debug64$error(E).
% Called from take$action in debug64.pro
%except$(debug_abort) :-
   % 1=clean exit (0=reset & continue, 3=break)
%   abort(1).
except$(error(Err, Attrs)) :-
   write(Err), nl,
   member(rc = RC, Attrs),
   member(type = TYPE, Attrs),
   member(message = MSG, Attrs),
   write(RC), nl, write(MSG), nl, 
   member(predicate = PRED, Attrs),
   write($While executing: $), write(PRED), nl, 
   (
      TYPE == read ->
      member(read_buffer = RB, Attrs),
      write($Read buffer: $), write(RB), nl, 
      member(read_file = RF, Attrs),
      (
         RF == $$ ->
         true ;

         write($File: $), write(RF), 
         member(line_number = LN, Attrs),
         write($ Line $), write(LN), nl
      ) ;

      true
   ),
   (exception$debug$stack(RawStack) ->
      amzi_system:filter_stack(RawStack, Stack),
      amzi_system:debug64(on),
      amzi_system:debug$report('FAIL', exception, exception, -1, Stack)
      ;
      true),
   member(callstack = CALLSTACK, Attrs),
   write($Call stack:\n$), write(CALLSTACK), nl, !, 
   what$next(TYPE).
except$(E) :-
   write($Unexpected Catch: $), writeq(E), nl, 
   fail.                        % fail continues the repeat/fail listener loop.

% what$next - disposition after exception, success ends the listener
%  repeat/fail loop, failure continues it.

what$next(abort) :- !,
   write($Aborting listener\n$).
what$next(internal) :- !,
   write($Internal error, aborting listener, contact Amzi! technical support\n$).
what$next(fatal) :- !,
   write($Prolog resource exhausted, stacks and heaps reinitialized.\n$), 
   fail.
what$next(_) :-
   fail.


%-------------------------------------------------------------------
% The main listener entry point
%

listen$(X) :-
   tag(debug_abort),
   exp$listen$term(X, XE),
   do$(XE).

greetings :-
   write(`\n  Amzi! Prolog Listener `),
   write(`\n  Version: `),
   version(Ver), write(Ver), nl,
   write(`  Copyright (c) 1992-2009 Amzi! inc. All Rights Reserved.\n`),
   op$en(X),
   greetings(X).

greetings(_) :-
   !,
   write(`\n  ****************************************************\n`), 
   amzi_system:license$info(product_type_str, PRODUCT),
   greetings_product(PRODUCT),
   write(`  ****************************************************\n`).

greetings_product(P) :-
   sub_string(P, 3, 1, `_`),
   write(`             EVALUATION COPY\n`),
   write(` Ask your school, company or organization to buy\n`),
   write(`       an Education or Enterprise license,\n`),
   write(`         or buy an individual license.\n`),
   write(`             www.amzi.com\n`).
greetings_product(TYPE) :-
   amzi_system:license$info(product_name_str, NAME),
   amzi_system:license$info(maint_days_left, DAYS),
   amzi_system:license$info(user_name_str, USER),
   write(`  `),
   write(NAME), write(` `), write(`Edition\n`),
   write(`  Licensed to `), write(USER), nl,
   (DAYS > 0 ->
      write(`  Maintenance & Support Expires in `), write(DAYS), write(` days\n`)
   ;
      write(`  Maintenance & Support has Expired\n`)
   ).

product_name('APS', `Developer`).
product_name('APX', `Professional`).
product_name('AP1', `Student`).

unl$defined :-
   defined(amzi_register:unl$sta/1).

op$en(Status) :-
   unl$defined, !,
   unl$sta(Status).
op$en(i).

exp$date(M, MonName, D, Y) :-
   unl$defined, !,
   unl$ctm(M, MonName, D, Y).
exp$date(_, _, _, _).

un$lock(FileS, UserS, OrgS, ProdS, KeyS) :-
   unl$defined, !,
   unl$rid(FileS, UserS, OrgS, $$, ProdS, KeyS).
un$lock(_, _, _, _, _).

who$ami(User, Org, Product, Platform, Version) :-
   unl$defined, !,
   unl$gri(User, Org, _, _, _),
   unl$gid(Product, Platform, Version, _, _).
who$ami(`System`, `Amzi! inc.`, `APX`, $$, `6.2`).

who$ami(User, Org, Product, Platform, Version, SerialNo) :-
   unl$defined, !,
   unl$gri(User, Org, _, _, _),
   unl$gid(Product, Platform, Version, _, _).
who$ami(`System`, `Amzi! inc.`, `APX`, $$, `6.2`, $$).

%-------------------------------------------------------------------
% Things to do
%
% these all appear as built-ins to listener, but aren't.
%

do$(X) :-                                  % Integers and variables are no good
   (integer(X) ;  var(X)),
   current_user(_, OH, _),
   write(OH, `\nBAD GOAL : `), write(OH, X), !, 
   fail.
do$(end_of_file) :- !.                       % Ctrl-Z (EOF) or quit gets out
do$(quit) :- !.
do$((A :- B)) :-    % Many ways to add your clauses
   assertz(user:(A :- B)),
   current_user(_, OH, _),
   write(OH, `Term asserted`), !, 
   fail.
do$([H|T]) :- !,
   do$(consult([H|T])).
do$(add) :-
   current_user(_, OH, _),
   write(OH, `Adding typed clauses to dynamic predicates\n`), 
   write(OH, `Type 'quit.' to end\n`), !, 
   do$(consult(user)).
do$(replace) :-
   current_user(_, OH, _),
   write(OH, `Replacing dynamic predicates with those typed\n`), 
   write(OH, `Type 'quit.' to end\n`), !, 
   do$(reconsult(user)).
do$(edit(FileName)) :-                         % Edit and reload
   get_editor(Editor),
   file$name(FileName, pro, FileNameA),
   atom_codes(FileNameA, File),
   append(Editor, " ", Comm),
   append(Comm, File, Command),
   comm(Command),
   reconsult(FileName),
   current_user(_, OH, _),
   write(OH, `Reconsulted `), write(OH, FileName), nl(OH), !, 
   fail.

% Various debugging options

do$(debug) :-                                  % Debug
   set_debug(on), !,
   fail.
do$(nodebug) :-
   set_debug(off), !,
   fail.
do$(trace) :-
   set_mode(trace, on), !,
   fail.
do$(notrace) :-
   set_mode(trace, off), !,
   fail.
do$(spy) :-
   spy, !,
   fail.
do$(spy(S)) :-
   spy(S), !,
   fail.
do$(leash) :-
   leash, !,
   fail.
do$(leash(X)) :-
   amzi_debugger:leash(X), !,
   fail.
do$(debug64(X)) :-
   debug64(X), !,
   fail.

% If none of the above, a normal call

do$(X) :-                               % Prove normal goals
   varlist(VNL), 
   varsof(X, VL),
   current_user(_,OH,_),
%	fugit(X),
   (X = M:G -> true; M = user, G = X),
   (amzi_system:debug64$initialized -> listen$call(M:G); call(M:G)),
   write_vars(VNL, VL, 0, Nvars), 
   (Nvars == 0 ->
      MORE = no,
      nl(OH)
      ;
      tab(OH,1),
      respkey(Ans),
      more$(Ans, MORE) ),
   %   (Ans == 0'; -> MORE = yes; MORE = no) ),
   % (user_more -> MORE = yes; MORE = no) ),
   % (Ans == 0'. ; Ans == 13 ; Ans == 10),
   MORE == no,
   write(OH, `yes`),  % yes we're done, no more
   !, 
   fail.
do$(X) :-
   current_user(_, OH, _),
   write(OH, `no`), !, 
   fail.

more$(0';, yes).
more$(0'., no).
more$(13, no).
more$(10, no).
more$(_, yes).

% so we can call debug$call with the real goals
% added the open file for the dummy listener file to make the eclipse
% debugger happy and have a file to display when it's looking at the
% beginning stack frames with this call.
listen$call(X) :-
   varlist(VNL), 
   varsof(X, VL),
   get$varlist(VNL, VL, Vars),
%   amzi_system:debug_init,
%   open('bin/listen_debug.txt', write, H),
%   write(H, '?- '),
%   write(H, X),
%   write(H, '.\n'),
%   close(H),
%   debug$info(X, 'bin/listen_debug.txt', 1, _, Vars, _),
   debug$info(X, listener, 1, _, Vars, _),
   listen$call2(X).

get$varlist([], [], []).
get$varlist([CharList|CharLists], [Var|Vars], [Name=Var|Pairs]) :-
   atom_codes(Name, CharList),
   !, get$varlist(CharLists, Vars, Pairs).

listen$call2(M:(A,B)) :-
   !,
   listen$call2(M:A),
   listen$call2(M:B).
listen$call2(M:(A;B)) :-
   !,
   (listen$call2(M:A) ;
    listen$call2(M:B)).
listen$call2(M:(A->B;C)) :-
   !,
   (listen$call2(A) ->
      listen$call2(B) ;
      listen$call2(C) ).
%listen$call2(M:G) :-
%   debug$call(M:G, 'bin/listen_debug.txt', 1, _, _, _, _).
listen$call2(M:G) :-
   debug$call(M:G, listener, 1, _, _, _, _).

fugit(X):-                                      % tempus fugit while calling X
	TimeA is cpuclock,                           % an integer
	call(X),
	TimeB is cpuclock, 
	Interval is TimeB - TimeA, 
	write(Interval), write(` msecs`), nl.

%-------------------------------------------------------------------
% Debugging predicates, hooks into debug.pro
%

spy :-
   current_user(_, OH, _),
   write(OH, `\nSpying:`), 
   spypoint(S),
   nl(OH), write(OH, `   `), write(OH, S), 
   fail.
spy.

leash :-
   current_user(_, OH, _),
   write(OH, `\nLeashing: `), 
   leashport(X),
   write(OH, X), write(OH, ` `), 
   fail.
leash :-
   nl.

%-------------------------------------------------------------------
% Debugger and Listener User I/O
%

bug_message(M) :-
   write(M), nl.

bug_goal_report(Port, Invoke, Goal, Num) :-
   Ndent is Invoke mod 10,
   Tens is 10*(Invoke//10),
   (Tens > 0 -> (write(`[`), write(Tens), write(`] `)) ;  write(`[] `)),
   tab(Ndent), write(Port), 
   (Num > 0 -> (write(` (`), write(Num), write(`)`)) ;  tab(1)),
   bug$write(Goal).

bug$write(X) :-
   writeq(X).

bug_action(X) :-
   var(X), !,
   write(` ? `), 
   flush_out,
   respkey(X).
bug_action(nl) :- !,
   nl.

bug_noclause(M,F,A) :-
   write(`Warning: No clauses for `), write(M:F/A), nl.


%-------------------------------------------------------------------
% Miscellaneous predicates
%

append([], X, X).
append([A|X],Y,[A|Z]) :- append(X,Y,Z).

member(A, [A|_]).
member(A, [_|Z]) :- member(A,Z).

write_vars([], [], N, N) :-
%telling(CurOut), fflush(CurOut), !.
   current_user(_, OH, _),
   fflush(OH), !.
write_vars([[0'*|_]|TN], [HV|TV], Sub, Tot) :- !,
   write_vars(TN, TV, Sub, Tot).
write_vars([HN|TN], [HV|TV], Sub, Tot) :-
   string_list(SHN, HN),
   current_user(_, OH, _),
   nl(OH), write(OH, SHN), write(OH, ` = `), writeq(OH, HV),
   Sub2 is Sub + 1,
   write_vars(TN, TV, Sub2, Tot).
% Force call$i of expand_term so debugger won't pick it up

exp$listen$term(X, XE) :- call(expand_term(X, XE)), !.
exp$listen$term(X, X).

get_editor(ProgL) :-
   amzi_system:'{sys}editor$'(Edit),
   (atom(Edit) -> atom_codes(Edit, EditL) ;  true),
   (list(Edit) -> EditL = Edit ;  true),
   (string(Edit) -> string_list(Edit, EditL) ;  true),
   append(EditL, " ", ProgL).

% Add a default extension to a filename, if necessary

file$name(File, _, File) :-
   file_exists(File), !.
file$name(File, Ext, FileName) :-
   atom(Ext),
   f$name(File, Ext, FileName).
file$name(File, [Ext|_], FileName) :-
   f$name(File, Ext, FileName), !.
file$name(File, [_|Rest], FileName) :-
   file$name(File, Rest, FileName).
file$name(File, _, File).

f$name(FileA, ExtA, FileNameA) :-
   atom_codes(FileA, FileL),
   not(member(0'., FileL)),
   atom_codes(ExtA, ExtL),
   append(FileL, ".", _L),
   append(_L, ExtL, FileNameL),
   atom_codes(FileNameA, FileNameL),
   file_exists(FileNameA), !.

:- end_body(amzi_listener).



